interface Array<T> {
  aggregate<U>(func: (accumulate: U, item: T) => U, seed: U): U;
  all(predicate: (item: T) => boolean): boolean;  
  any(predicate?: (item: T) => boolean): boolean;
  average(selector?: (item: T) => number): number;
  concatLt(...items: (T | ConcatArray<T>)[]): T[];
  contains(element: T, comparer?: (a: T, b: T) => boolean): boolean;
  count(predicate?: (item: T) => boolean): number;
  defaultIfEmpty(defaultValue?: T): T[];
  distinct(comparer?: (a: T, b: T) => boolean): T[];
  elementAt(index: number): T;
  elementAtOrDefault(index: number): T | null;
  except(second: T[], comparer?: (a: T, b: T) => boolean): T[];
  first(predicate?: (item: T) => boolean): T;
  firstOrDefault(predicate?: (item: T) => boolean): T | null;
  groupBy<TKey>(keySelector: (item: T) => TKey): IGrouping<TKey, T>[];
  intersect(second: T[], comparer?: (a: T, b: T) => boolean): T[];
  joinLt<U, R>(inner: U[], outerKeySelector: (item: T) => any, innerKeySelector: (item: U) => any, resultSelector: (outer: T, inner: U) => R): R[];
  last(predicate?: (item: T) => boolean): T;
  lastOrDefault(predicate?: (item: T) => boolean): T | null;
  max(selector?: (item: T) => number): number;
  min(selector?: (item: T) => number): number;
  orderBy<TKey>(keySelector: (item: T) => TKey): T[];
  orderByDescending<TKey>(keySelector: (item: T) => TKey): T[];
  reverseLt(): T[];
  select<U>(selector: (item: T, index: number) => U): U[];
  selectMany<U>(selector: (item: T) => U[]): U[];
  sequenceEqual(second: T[], comparer?: (a: T, b: T) => boolean): boolean;
  single(predicate?: (item: T) => boolean): T;
  singleOrDefault(predicate?: (item: T) => boolean): T | null;
  skip(count: number): T[];
  sum(selector?: (item: T) => number): number;
  take(count: number): T[];
  thenBy<TKey>(keySelector: (item: T) => TKey): T[];
  thenByDescending<TKey>(keySelector: (item: T) => TKey): T[];
  union(second: T[], comparer?: (a: T, b: T) => boolean): T[];
  where(predicate: (item: T, index: number) => boolean): T[]; 
  zip<U, R>(second: U[], resultSelector: (first: T, second: U) => R): R[];  
}